#-------------------------------#-------------------------------#
算法学习路线：
#-------------------------------#-------------------------------#
1 算法数据结构体系学习班(1-40集)--41之后可以酌情看看，比较难
    https://ke.qq.com/course/3067253#term_id=103187834
2 算法与数据结构进阶班17-48课 49-78课leetcode高频题
    https://ke.qq.com/course/2585663#term_id=102690867
3 大厂刷题班
    https://ke.qq.com/course/3449042#term_id=103585161
4 每周有营养的大厂算法面试题
    https://ke.qq.com/course/4122671#term_id=104277375
注意：标注出代码核心的代码！！！

#-------------------------------#-------------------------------#
算法的实现思路
1 由简单到复杂
    验证一步走一步
    多打印中间结果
2 先局部后整体
    没有思路时先细分
3 先粗糙后精细
    变量更名
    语句合并
    边界处理

#-------------------------------#-------------------------------#
介绍
数组：不方便修改删除 方便查找
链表：方便修改删除 不方便查找
前缀和：计算数组下标n到m的和

对数器：自己调试排序是否正确，生成随机样本做比对

#-------------------------------#-------------------------------#
认识复杂度、对数器、二分法
#-------------------------------#-------------------------------#
只关心最高阶，比如平方
等差数列求和公式
常数操作：固定时间

时间复杂度排序：
O(1) O(logN) O(N) O(N*logN) 
O(N^2)...O(N^K)
O(2^N)...O(K^N) #递归

#-------------------------------#-------------------------------#
Master公式
#-------------------------------#-------------------------------#
形如
T(N) = a * T(N/b) + O(N^d) （其中a b d 都是常数）
的递归函数，可以直接通过Master公式来确定时间复杂度
如果 log(b,a) < d 复杂度为 O(N^d)
如果 log(b,a) > d 复杂度为 O(N^log(b,a))
如果 log(b,a) == d 复杂度为 O(N^(d * logN))
log(b,a) 以b为底
